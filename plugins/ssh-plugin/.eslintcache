[{"/home/simon/Documents/Workspaces/EclipseSource/ecore-glsp-che/client/plugins/ssh-plugin/src/node/ssh-key-manager.ts":"1","/home/simon/Documents/Workspaces/EclipseSource/ecore-glsp-che/client/plugins/ssh-plugin/src/ssh-plugin-backend.ts":"2"},{"size":3559,"mtime":1591263742346,"results":"3","hashOfConfig":"4"},{"size":16958,"mtime":1591263742346,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"15ancnw",{"filePath":"8","messages":"9","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"10"},"/home/simon/Documents/Workspaces/EclipseSource/ecore-glsp-che/client/plugins/ssh-plugin/src/node/ssh-key-manager.ts",[],"/home/simon/Documents/Workspaces/EclipseSource/ecore-glsp-che/client/plugins/ssh-plugin/src/ssh-plugin-backend.ts",["11"],"/*********************************************************************\n * Copyright (c) 2019 Red Hat, Inc.\n *\n * This program and the accompanying materials are made\n * available under the terms of the Eclipse Public License 2.0\n * which is available at https://www.eclipse.org/legal/epl-2.0/\n *\n * SPDX-License-Identifier: EPL-2.0\n **********************************************************************/\n\nimport * as theia from '@theia/plugin';\nimport * as che from '@eclipse-che/plugin';\nimport { RemoteSshKeyManager, SshKeyManager } from './node/ssh-key-manager';\nimport { che as cheApi } from '@eclipse-che/api';\nimport { resolve, join } from 'path';\nimport { pathExists, unlink, ensureFile, chmod, readFile, writeFile, appendFile, access, remove, mkdtemp } from 'fs-extra';\nimport * as os from 'os';\nimport { R_OK } from 'constants';\nimport { spawn } from 'child_process';\n\nexport async function start(): Promise<void> {\n\n    const sshKeyManager = new RemoteSshKeyManager();\n    let keys: cheApi.ssh.SshPair[] = [];\n    try {\n        keys = await getKeys(sshKeyManager);\n    } catch (e) {\n        if (e.message !== 'No SSH key pair has been defined.') {\n            console.error(e.message);\n        }\n    }\n    const keyPath = (keyName: string | undefined) => keyName ? '/etc/ssh/private/' + keyName : '';\n    const passphrase = (privateKey: string | undefined) => privateKey ? privateKey.substring(privateKey.indexOf('\\npassphrase: ') + 13, privateKey.length - 1) : '';\n    keys.filter(key => isEncrypted(keyPath(key.name))).forEach(key => registerKey(keyPath(key.name), passphrase(key.privateKey)));\n\n    let gitLogHandlerInitialized: boolean;\n    /* Git log handler, listens to Git events, catches the clone and push events.\n    Asks to Upload a public SSH key if needed before these operations.\n    Authenticates to Github if needed. */\n    const onChange = () => {\n        // Get the vscode Git plugin if the plugin is started.\n        const gitExtension = theia.plugins.getPlugin('vscode.git');\n        if (!gitLogHandlerInitialized && gitExtension && gitExtension.exports) {\n            // Set the initialized flag to true state, to not to initialize the handler again on plugin change event.\n            gitLogHandlerInitialized = true;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const git: any = gitExtension.exports._model.git;\n            let command: string;\n            let url: string;\n            let path: string;\n            const listener = async (out: string) => {\n                // Parse Git log events.\n                const split = out.split(' ');\n                if (out.startsWith('> git clone') || out.startsWith('> git push')) {\n                    command = split[2];\n                    url = split[3];\n                    path = split[4];\n                    // Catch the remote access error.\n                } else if (out.indexOf('Permission denied (publickey).') > -1) {\n                    // If the remote repository is a GitHub repository, ask to upload a public SSH key.\n                    if (await che.oAuth.isRegistered('github') && out.indexOf('git@github.com') > -1) {\n                        switch (command) {\n                            case 'clone': {\n                                if (await askToGenerateIfEmptyAndUploadKeyToGithub(keys, true)) {\n                                    await git.clone(url, path.substring(0, path.lastIndexOf('/')));\n                                    theia.window.showInformationMessage(`Project ${url} successfully cloned to ${path}`);\n                                }\n                                break;\n                            }\n                            case 'push': {\n                                if (await askToGenerateIfEmptyAndUploadKeyToGithub(keys, false)) {\n                                    theia.window.showInformationMessage('The public SSH key has been uploaded to Github, please try to push again.');\n                                }\n                                break;\n                            }\n                        }\n                        // If the remote repository is not a GitHub repository, show a proposal to manually add a public SSH key to related Git provider.\n                    } else {\n                        showWarningMessage(keys.length === 0);\n                    }\n                }\n            };\n            // Set the git log listener.\n            git.onOutput.addListener('log', listener);\n        }\n    };\n\n    const showWarningMessage = (showGenerate: boolean, gitProviderName?: string) =>\n        theia.window.showWarningMessage(`Permission denied, please ${showGenerate ? 'generate (F1 => ' + GENERATE.label + ') and ' : ''}\n        upload your public SSH key to ${gitProviderName ? gitProviderName : 'the Git provider'} and try again. To get the public key press F1 => ${VIEW.label}`);\n\n    theia.plugins.onDidChange(onChange);\n\n    const askToGenerateIfEmptyAndUploadKeyToGithub = async (keysParam: cheApi.ssh.SshPair[], tryAgain: boolean): Promise<boolean> => {\n        let key = keysParam.find(k => !!k.publicKey && !!k.name && (k.name.startsWith('github.com') || k.name.startsWith('default-')));\n        const message = `Permission denied, would you like to ${!key ? 'generate and ' : ''}upload the public SSH key to GitHub${tryAgain ? ' and try again' : ''}?`;\n        const action = await theia.window.showWarningMessage(message, key ? 'Upload' : 'Generate and upload');\n        if (action) {\n            if (!key) {\n                key = await sshKeyManager.generate('vcs', 'github.com');\n                await updateConfig('github.com');\n                await writeKey('github.com', key.privateKey!);\n            }\n            if (key && key.publicKey) {\n                await che.github.uploadPublicSshKey(key.publicKey);\n                return true;\n            }\n            return false;\n        } else {\n            return false;\n        }\n    };\n\n    const GENERATE_FOR_HOST: theia.CommandDescription = {\n        id: 'ssh:generate_for_host',\n        label: 'SSH: generate key pair for particular host...'\n    };\n    const GENERATE: theia.CommandDescription = {\n        id: 'ssh:generate',\n        label: 'SSH: generate key pair...'\n    };\n    const CREATE: theia.CommandDescription = {\n        id: 'ssh:create',\n        label: 'SSH: create key pair...'\n    };\n    const DELETE: theia.CommandDescription = {\n        id: 'ssh:delete',\n        label: 'SSH: delete key pair...'\n    };\n    const VIEW: theia.CommandDescription = {\n        id: 'ssh:view',\n        label: 'SSH: view public key...'\n    };\n    const UPLOAD: theia.CommandDescription = {\n        id: 'ssh:upload',\n        label: 'SSH: upload private key...'\n    };\n\n    theia.commands.registerCommand(GENERATE_FOR_HOST, () => {\n        generateKeyPairForHost(sshKeyManager);\n    });\n    theia.commands.registerCommand(GENERATE, () => {\n        generateKeyPair(sshKeyManager);\n    });\n    theia.commands.registerCommand(CREATE, () => {\n        createKeyPair(sshKeyManager);\n    });\n    theia.commands.registerCommand(DELETE, () => {\n        deleteKeyPair(sshKeyManager);\n    });\n    theia.commands.registerCommand(VIEW, () => {\n        viewPublicKey(sshKeyManager);\n    });\n    theia.commands.registerCommand(UPLOAD, () => {\n        uploadPrivateKey(sshKeyManager);\n    });\n}\n\nconst RESTART_WARNING_MESSAGE = 'Che Git plugin can leverage the generated keys now. To make them available in all workspace containers please restart your workspace.';\nconst ENTER_KEY_NAME_OR_LEAVE_EMPTY_MESSAGE = 'Please provide a hostname (e.g. github.com) or leave empty to setup default name';\n\nconst hostNamePattern = new RegExp('[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*');\n\nconst getHostName = async (message?: string) => await theia.window.showInputBox({\n    placeHolder: message ? message : 'Please provide a hostname e.g. github.com',\n    validateInput: (text: string) => {\n        if (!hostNamePattern.test(text)) {\n            return 'Invalid hostname';\n        }\n    }\n});\n\nconst getKeyFilePath = (name: string) => resolve(os.homedir(), '.ssh', name.replace(new RegExp('\\\\.'), '_'));\n\nconst updateConfig = async (hostName: string) => {\n    const configFile = resolve(os.homedir(), '.ssh', 'config');\n    await ensureFile(configFile);\n    await chmod(configFile, '644');\n    const keyConfig = `\\nHost ${hostName.startsWith('default-') ? '*' : hostName}\\nIdentityFile ${getKeyFilePath(hostName)}\\nStrictHostKeyChecking = no\\n`;\n    const configContentBuffer = await readFile(configFile);\n    if (configContentBuffer.indexOf(keyConfig) >= 0) {\n        const newConfigContent = configContentBuffer.toString().replace(keyConfig, '');\n        await writeFile(configFile, newConfigContent);\n    } else {\n        await appendFile(configFile, keyConfig);\n    }\n};\n\nconst writeKey = async (name: string, key: string) => {\n    const keyFile = getKeyFilePath(name);\n    await appendFile(keyFile, key);\n    await chmod(keyFile, '600');\n};\n\nconst showWarning = async (message: string) => {\n    await theia.window.showWarningMessage(message);\n};\n\nconst generateKeyPair = async (sshkeyManager: SshKeyManager) => {\n    const keyName = `default-${Date.now()}`;\n    const key = await sshkeyManager.generate('vcs', keyName);\n    await updateConfig(keyName);\n    await writeKey(keyName, key.privateKey!);\n    const viewAction = 'View';\n    const action = await theia.window.showInformationMessage('Key pair successfully generated, do you want to view the public key?', viewAction);\n    if (action === viewAction && key.privateKey) {\n        const document = await theia.workspace.openTextDocument({ content: key.publicKey })!;\n        await theia.window.showTextDocument(document!);\n    }\n    showWarning(RESTART_WARNING_MESSAGE);\n};\n\nconst generateKeyPairForHost = async (sshkeyManager: SshKeyManager) => {\n    const hostName = await getHostName();\n    if (!hostName) {\n        return;\n    }\n    const key = await sshkeyManager.generate('vcs', hostName);\n    await updateConfig(hostName);\n    await writeKey(hostName, key.privateKey!);\n    const viewAction = 'View';\n    const action = await theia.window.showInformationMessage(`Key pair for ${hostName} successfully generated, do you want to view the public key?`, viewAction);\n    if (action === viewAction && key.privateKey) {\n        const document = await theia.workspace.openTextDocument({ content: key.publicKey });\n        await theia.window.showTextDocument(document!);\n    }\n    showWarning(RESTART_WARNING_MESSAGE);\n};\n\nconst createKeyPair = async (sshkeyManager: SshKeyManager) => {\n    let hostName = await getHostName(ENTER_KEY_NAME_OR_LEAVE_EMPTY_MESSAGE);\n    if (!hostName) {\n        hostName = `default-${Date.now()}`;\n    }\n    const publicKey = await theia.window.showInputBox({ placeHolder: 'Enter public key' });\n    const privateKey = await theia.window.showInputBox({ placeHolder: 'Enter private key' });\n\n    try {\n        await sshkeyManager.create({ name: hostName, service: 'vcs', publicKey: publicKey, privateKey });\n        await updateConfig(hostName);\n        await writeKey(hostName, privateKey!);\n        await theia.window.showInformationMessage(`Key pair for ${hostName} successfully created`);\n        showWarning(RESTART_WARNING_MESSAGE);\n    } catch (error) {\n        theia.window.showErrorMessage(error);\n    }\n};\n\nconst uploadPrivateKey = async (sshkeyManager: SshKeyManager) => {\n    let hostName = await getHostName(ENTER_KEY_NAME_OR_LEAVE_EMPTY_MESSAGE);\n    if (!hostName) {\n        hostName = `default-${Date.now()}`;\n    }\n\n    const tempDir = await mkdtemp(join(os.tmpdir(), 'private-key-'));\n    const uploadedFilePaths = await theia.window.showUploadDialog({ defaultUri: theia.Uri.file(tempDir) });\n\n    if (!uploadedFilePaths || uploadPrivateKey.length === 0) {\n        theia.window.showErrorMessage('No private key has been uploaded');\n        return;\n    }\n\n    const privateKeyPath = uploadedFilePaths[0];\n\n    await access(privateKeyPath.path, R_OK);\n\n    const privateKeyContent = (await readFile(privateKeyPath.path)).toString();\n\n    try {\n        await sshkeyManager.create({ name: hostName, service: 'vcs', privateKey: privateKeyContent });\n        await updateConfig(hostName);\n        await writeKey(hostName, privateKeyContent);\n        const keyPath = getKeyFilePath(hostName);\n        let passphrase;\n        if (await isEncrypted(keyPath)) {\n            passphrase = await theia.window.showInputBox({ placeHolder: 'Enter passphrase for key', password: true });\n            if (passphrase) {\n                await registerKey(keyPath, passphrase);\n            } else {\n                theia.window.showErrorMessage('Passphrase for key was not entered');\n            }\n        }\n        theia.window.showInformationMessage(`Key pair for ${hostName} successfully uploaded`);\n        showWarning(RESTART_WARNING_MESSAGE);\n    } catch (error) {\n        theia.window.showErrorMessage(error);\n    }\n\n    await unlink(privateKeyPath.path);\n    await remove(tempDir);\n};\n\nconst getKeys = async (sshKeyManager: SshKeyManager): Promise<cheApi.ssh.SshPair[]> => {\n    const keys: cheApi.ssh.SshPair[] = await sshKeyManager.getAll('vcs');\n    if (!keys || keys.length < 1) {\n        throw new Error('No SSH key pair has been defined.');\n    }\n    return keys;\n};\n\nconst deleteKeyPair = async (sshkeyManager: SshKeyManager) => {\n    let keys: cheApi.ssh.SshPair[];\n    try {\n        keys = await getKeys(sshkeyManager);\n    } catch (error) {\n        showWarning('Delete SSH key operation is interrupted: ' + error.message);\n        return;\n    }\n    const keyResp = await theia.window.showQuickPick<theia.QuickPickItem>(keys.map(key =>\n        ({ label: key.name ? key.name : '' })), {});\n    const keyName = keyResp ? keyResp.label : '';\n\n    try {\n        await sshkeyManager.delete('vcs', keyName);\n        const keyFile = getKeyFilePath(keyName);\n        if (await pathExists(keyFile)) {\n            await unlink(keyFile);\n            await updateConfig(keyName);\n        }\n        theia.window.showInformationMessage(`Key ${keyName} successfully deleted`);\n    } catch (error) {\n        theia.window.showErrorMessage(error);\n    }\n};\n\nasync function registerKey(keyPath: string, passphrase: string): Promise<void> {\n    try {\n        await sshAdd(keyPath, passphrase);\n    } catch (e) {\n        if (e.includes('Could not open a connection to your authentication agent')) {\n            await startSshAgent();\n            await sshAdd(keyPath, passphrase);\n        }\n    }\n}\n\nasync function isEncrypted(keyPath: string): Promise<boolean> {\n    return new Promise<boolean>(resolvePromise => {\n        const command = spawn('sshpass', ['-p', '', '-P', 'assphrase', 'ssh-keygen', '-y', '-f', keyPath]);\n        command.stdout.on('data', data => {\n            resolvePromise(false);\n        });\n        command.stderr.on('data', data => {\n            if (data.includes('incorrect passphrase supplied to decrypt private key')) {\n                resolvePromise(true);\n            }\n        });\n    });\n}\n\nfunction sshAdd(keyPath: string, passphrase: string): Promise<void> {\n    return new Promise<void>((resolvePromise, reject) => {\n        const command = spawn('sshpass', ['-p', passphrase, '-P', 'assphrase', 'ssh-add', keyPath]);\n        command.stderr.on('data', async (data: string) => {\n            reject(data);\n        });\n        command.on('close', () => {\n            resolvePromise();\n        });\n    });\n}\n\nfunction startSshAgent(): Promise<void> {\n    return new Promise<void>((resolvePromise, reject) => {\n        const command = spawn('ssh-agent', ['-s']);\n        command.stderr.on('data', async (data: string) => {\n            reject(data);\n        });\n        command.stdout.on('data', async data => {\n            const dataString = data.toString();\n            const env = dataString.substring(0, dataString.indexOf('='));\n            const value = dataString.substring(dataString.indexOf('=') + 1, dataString.indexOf(';'));\n            process.env[env] = value;\n        });\n        command.on('close', () => {\n            resolvePromise();\n        });\n    });\n}\n\nconst viewPublicKey = async (sshkeyManager: SshKeyManager) => {\n    let keys: cheApi.ssh.SshPair[];\n    try {\n        keys = await getKeys(sshkeyManager);\n    } catch (error) {\n        showWarning('View public SSH key operation is interrupted: ' + error.message);\n        return;\n    }\n    const keyResp = await theia.window.showQuickPick<theia.QuickPickItem>(keys.map(key =>\n        ({ label: key.name ? key.name : '' })), {});\n    const keyName = keyResp ? keyResp.label : '';\n    try {\n        const key = await sshkeyManager.get('vcs', keyName);\n        const document = await theia.workspace.openTextDocument({ content: key.publicKey });\n        theia.window.showTextDocument(document!);\n    } catch (error) {\n        theia.window.showErrorMessage(error);\n    }\n};\n\nexport function stop(): void {\n\n}\n",{"ruleId":"12","severity":1,"message":"13","line":164,"column":49,"nodeType":"14","endLine":171,"endColumn":3},"no-return-await","Redundant use of `await` on a return value.","Identifier"]